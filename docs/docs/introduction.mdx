---
sidebar_position: 1
sidebar_label: Introduction
sidebar: 'docsSidebar'
---
import CodeBlock from '@site/src/theme/CodeBlock';
import { Database, Route, Puzzle, Activity, ShieldCheck, Rocket } from 'lucide-react';


# Timbal
<h3 className="subtitle" style={{marginTop: '-17px', fontSize: '1.1rem', fontWeight: 'normal'}}>
Build reliable AI applications (...)
</h3>

---

## Overview

**Timbal is an open-source framework for designing autonomous AI applications with flexible orchestration, real-time streaming, and multi-provider support.**

Timbal empowers developers with both **high-level simplicity** and **precise low-level control**, ideal for creating autonomous AI applications tailored to any scenario.

Timbal provides two main patterns for building AI applications:

- **[Agents](./agents)**: Agents are autonomous execution units that orchestrate LLM interactions with tool calling. 
  
  Best for:
  - Complex reasoning tasks requiring multiple steps
  - Dynamic tool selection based on context
  - Open-ended problem solving with autonomous decision making
  - Multi-turn conversations with memory across iterations

  <div style={{marginTop: '1.5rem', marginBottom: '1.5rem'}}>
  
    <CodeBlock language="python" code ={`from timbal import Agent

    agent = Agent(
        name="my_agent",
        model="openai/gpt-4.1",
        tools=[search_web],
    )`}
    />
  </div>
  
- **[Workflows](./workflows)**: Fine-grained control over your AI pipeline with explicit step-by-step execution. 
  
  Best for:
  - Complex data processing pipelines with multiple stages
  - Predictable processes with defined execution paths
  - Performance-critical applications requiring concurrent execution
  - Workflows where explicit control over step dependencies is needed

  <div style={{marginTop: '1.5rem', marginBottom: '1.5rem'}}>
  <CodeBlock language="python" code ={`from timbal import Workflow

  # Document Database Creation Flow
  workflow = (WorkFlow(name="my_workflow")
      .step(extract_text)
      .step(text_processor, raw_text=extract_text.output)
      .step(convert_to_database, text=text_processor.output", chunk_size=1000)
  )`}
    />
  </div>
  
Choose the pattern that best aligns with your application's requirements for control, flexibility, and predictability.


## Key Features

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(3, 1fr)',
  gap: '1rem',
  margin: '2rem 0'
}}>
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <Database size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Memory</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
  
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <Route size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Model Routing</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
  
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <Puzzle size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Composability</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
  
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <Activity size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Tracing</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
  
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <ShieldCheck size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Evals</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
  
  <div style={{
    padding: '1.5rem',
    borderRadius: '8px',
    backgroundColor: 'var(--ifm-card-background-color)',
    border: '1px solid var(--ifm-color-emphasis-200)',
    boxShadow: '0 2px 12px rgba(0, 0, 0, 0.05)',
  }}>
    <div style={{color: 'var(--ifm-color-primary)', marginBottom: '0.5rem'}}>
      <Rocket size={32} />
    </div>
    <h3 style={{fontSize: '1.3rem', marginBottom: '0.5rem', color: 'var(--ifm-color-primary)'}}>Deployment</h3>
    <p style={{fontSize: '0.95rem', marginBottom: '0', color: 'var(--ifm-color-emphasis-900)'}}>TODO</p>
  </div>
</div>

## Why are we building this?

- <span style={{color: 'var(--timbal-purple)'}}><strong>Simplicity over complexity.</strong></span> Unlike LangGraph, CrewAI, and other frameworks that abstract away what's really happening, Timbal keeps things transparent. Under the hood, it's just LLM calls and async function execution - no hidden magic, no opaque abstractions.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Developer experience first.</strong></span> We believe you shouldn't need to learn a new mental model to build AI applications. If you understand functions and async/await from any modern programming language, you understand Timbal. Most agents are built in 10-20 lines of code.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Battle-tested architecture.</strong></span> Our core abstractions have been refined through real-world production usage. The framework is designed around proven patterns: async generators, Pydantic validation, and event-driven processing.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Robust interfaces.</strong></span> Strong typing and validation make it nearly impossible to break things from the outside, while clean abstractions make internal modifications straightforward. The framework fails fast with clear error messages.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Performance by design.</strong></span> Built for production workloads with concurrent execution, efficient memory management, and minimal overhead. Every design decision prioritizes speed and scalability.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Stability in a chaotic ecosystem.</strong></span> Providers change APIs monthly. Timbal provides a stable abstraction that shields your applications in production.