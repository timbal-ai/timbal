---
title: Events, Traces & Streaming
sidebar: 'docsSidebar'
---
import CodeBlock from '@site/src/theme/CodeBlock';

# Events, Traces & Streaming

<h2 className="subtitle" style={{marginTop: '-17px', fontSize: '1.1rem', fontWeight: 'normal'}}>
Monitor execution in real-time, handle streaming results, debug your Runnables with comprehensive event tracking, and analyze detailed traces of execution flow.
</h2>

---

## What are Events?
Events are the communication mechanism that Runnables use to stream information throughout their execution lifecycle. Every Runnable execution produces a sequence of events that can be consumed in real-time or collected for later processing.


### Event Types

#### Start Event
Signals the beginning of a Runnable execution. 
<CodeBlock language="python" code={`from timbal.types.events import StartEvent

start_event = StartEvent(
    run_id="run_123",
    parent_run_id="parent_456", 
    path="workflow.step1",
    call_id="call_789",
    parent_call_id="parent_call_101"
)`}/>

#### Chunk Event
Contains streaming or intermediate results during execution (generators, async generators, streaming responses).
<CodeBlock language="python" code={`from timbal.types.events import ChunkEvent

chunk_event = ChunkEvent(
    run_id="run_123",
    parent_run_id="parent_456",
    path="workflow.step1", 
    call_id="call_789",
    parent_call_id="parent_call_101",
    chunk="Processing item 1..."
)`}/>


#### Output Event 
Contains the final result and execution metadata.

<CodeBlock language="python" code={`from timbal.types.events import OutputEvent

output_event = OutputEvent(
    run_id="run_123",
    parent_run_id="parent_456",
    path="workflow.step1",
    call_id="call_789", 
    parent_call_id="parent_call_101",
    input={"name": "Alice"},
    output="Hello, Alice!",
    error=None,
    t0=1640995200000,  # Start timestamp
    t1=1640995201000,  # End timestamp
    usage={"tokens": 150}
)`}/>


---
### Real-time execution
 <!--1. event pipeline, async code  -->
 All Runnables generate at least two events: Input and Output. All events generated by nested Runnables within a parent Runnable are stored and associated with the parent Runnable that initiated the execution.

Iterate over the async generator returned by calling a Runnable to process events in real-time:

 <CodeBlock language="python" code={`async for event in runnable(**kwargs):
    print(event)`}/> 

---
### The `Collect()` Method for Final Result Access
The `collect()` method extracts the final result from an async generator without manually iterating through all the events. It returns the output value from the Output Event.

<CodeBlock language="python" code={`# Instead of manually iterating through events
async for event in runnable(**kwargs):
    if isinstance(event, OutputEvent):
        result = event.output
        break

# You can simply use collect()
result = await runnable(**kwargs).collect()`}/> 


---

### Handle Errors
Check for errors in Output Events to handle exceptions:

<CodeBlock language="python" code={`async for event in runnable(**kwargs):
    if isinstance(event, OutputEvent) and event.error:
        print(f"Error: {event.error['message']}")
        print(f"Traceback: {event.error['traceback']}")`}/>

---

## What are Traces?

Timbal provides comprehensive execution tracing that captures every aspect of runnable execution, **from input parameters to final outputs, including timing data, error states, and usage metrics**. A <span style={{color: 'var(--timbal-purple)'}}><strong>Trace</strong></span> is the core data structure that captures execution information for every runnable execution, providing a complete audit trail of what happened. This tracing system enables complete observability into your application's behavior and performance.


### Events vs. Traces:
Output Events and Traces have a similar data, but serve different purposes. Events are in fact the source data that gets processed into persistent Trace records.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Events</strong></span> are real-time notifications that stream during execution. They provide immediate feedback about what's happening (start, progress chunks, completion) but are not stored permanently. Events are consumed as they're generated and are ideal for real-time monitoring, progress tracking, and streaming responses.

- <span style={{color: 'var(--timbal-purple)'}}><strong>Traces</strong></span> are persistent records that capture the complete execution context. They contain detailed execution metadata, timing information, resource usage, and complete input/output snapshots.

**Memory Management and Persistence**: Traces persistence enable memory management by tracking resource usage patterns, maintaining execution history for debugging, and supporting long-term performance analysis and audit trails.
