---
title: Events & Streaming
sidebar: 'docsSidebar_v2'
---
import CodeBlock from '@site/src/theme/CodeBlock';

# Events & Streaming

<h2 className="subtitle" style={{marginTop: '-17px', fontSize: '1.1rem', fontWeight: 'normal'}}>
Monitor execution in real-time, handle streaming results, and debug your Runnables with comprehensive event tracking.
</h2>

---

## What are Events?
Events are the communication mechanism that Runnables use to stream information throughout their execution lifecycle. Every Runnable execution produces a sequence of events that can be consumed in real-time or collected for later processing.

<!-- ### Event Properties
All events share common properties:
- `run_id`: Unique identifier for the execution run
- `parent_run_id`: ID of the parent run (for nested executions)
- `path`: Hierarchical path of the Runnable in the execution context
- `call_id`: Unique identifier for this specific call
- `parent_call_id`: ID of the parent call (for nested calls) -->

### Event Types

#### Start Event
Signals the beginning of a Runnable execution. 
<CodeBlock language="python" code={`from timbal.types.events import StartEvent

start_event = StartEvent(
    run_id="run_123",
    parent_run_id="parent_456", 
    path="workflow.step1",
    call_id="call_789",
    parent_call_id="parent_call_101"
)`}/>

#### Chunk Event
Contains streaming or intermediate results during execution (generators, async generators, streaming responses).
<CodeBlock language="python" code={`from timbal.types.events import ChunkEvent

chunk_event = ChunkEvent(
    run_id="run_123",
    parent_run_id="parent_456",
    path="workflow.step1", 
    call_id="call_789",
    parent_call_id="parent_call_101",
    chunk="Processing item 1..."
)`}/>


#### Output Event 
Contains the final result and execution metadata.

<CodeBlock language="python" code={`from timbal.types.events import OutputEvent

output_event = OutputEvent(
    run_id="run_123",
    parent_run_id="parent_456",
    path="workflow.step1",
    call_id="call_789", 
    parent_call_id="parent_call_101",
    input={"name": "Alice"},
    output="Hello, Alice!",
    error=None,
    t0=1640995200000,  # Start timestamp
    t1=1640995201000,  # End timestamp
    usage={"tokens": 150}
)`}/>


---
## Real-time execution
 <!--1. event pipeline, async code  -->
 All Runnables generate at least two events: Input and Output. All events generated by nested Runnables within a parent Runnable are stored and associated with the parent Runnable that initiated the execution.

To consume events in real-time, you can iterate over the async generator returned by calling a Runnable. This allows you to process events as they are generated.

 <CodeBlock language="python" code={`async for event in runnable(**kwargs):
    print(event)`}/> 

---
## The `Collect()` Method for Final Result Access
The `collect()` method is a key feature of the Runnable system that allows you to easily extract the final result from an async generator without manually iterating through all the events. This returns the output value from the Output Event.

<CodeBlock language="python" code={`# Instead of manually iterating through events
async for event in runnable(**kwargs):
    if isinstance(event, OutputEvent):
        result = event.output
        break

# You can simply use collect()
result = await runnable(**kwargs).collect()`}/> 


---

## Handle Errors
<CodeBlock language="python" code={`async for event in runnable(**kwargs):
    if isinstance(event, OutputEvent) and event.error:
        print(f"Error: {event.error['message']}")
        print(f"Traceback: {event.error['traceback']}")`}/>




